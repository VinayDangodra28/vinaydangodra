/**
 * Generates a maze of specified dimensions.
 *
 * @param {number} width - Width of the maze (number of columns).
 * @param {number} height - Height of the maze (number of rows).
 * Cell value: maze[row][col][n] is 0 (has wall) or 1 (no wall)
 * n == 0: north wall, n == 1: east wall
 * n == 2: south wall, n == 3: west wall
 *
 */
export function generateMaze(width, height) {
  // Establish variables and starting grid
  const totalCells = width * height;
  const maze = [];
  const unvisited = [];
  
  for (let row = 0; row < height; row++) {
    maze[row] = [];
    unvisited[row] = [];
    for (let col = 0; col < width; col++) {
      maze[row][col] = [0, 0, 0, 0]; // Walls: [north, east, south, west]
      unvisited[row][col] = true;   // Mark cell as unvisited
    }
  }

  // Set a random starting position
  let currentCell = [
    Math.floor(Math.random() * height),
    Math.floor(Math.random() * width)
  ];
  const path = [currentCell];
  unvisited[currentCell[0]][currentCell[1]] = false;
  let visited = 1;

  // Generate the maze using depth-first search
  while (visited < totalCells) {
    // Determine neighboring cells
    const potentialNeighbors = [
      [currentCell[0] - 1, currentCell[1], 0, 2], // North
      [currentCell[0], currentCell[1] + 1, 1, 3], // East
      [currentCell[0] + 1, currentCell[1], 2, 0], // South
      [currentCell[0], currentCell[1] - 1, 3, 1]  // West
    ];
    const neighbors = [];

    // Check if neighbors are within bounds and unvisited
    for (const [row, col, currentWall, neighborWall] of potentialNeighbors) {
      if (
        row >= 0 && row < height &&
        col >= 0 && col < width &&
        unvisited[row][col]
      ) {
        neighbors.push([row, col, currentWall, neighborWall]);
      }
    }

    if (neighbors.length > 0) {
      // Choose a random neighbor
      const [nextRow, nextCol, currentWall, neighborWall] = neighbors[Math.floor(Math.random() * neighbors.length)];

      // Remove walls between the current cell and the chosen neighbor
      maze[currentCell[0]][currentCell[1]][currentWall] = 1;
      maze[nextRow][nextCol][neighborWall] = 1;

      // Move to the neighbor
      unvisited[nextRow][nextCol] = false;
      visited++;
      currentCell = [nextRow, nextCol];
      path.push(currentCell);
    } else {
      // Backtrack to the previous cell
      currentCell = path.pop();
    }
  }
  return maze;
}

/**
 * Solves a maze and returns the solution path.
 *
 * @param {Array} maze - The maze generated by `generateMaze`.
 * @param {number} startX - Starting X (row index).
 * @param {number} startY - Starting Y (column index).
 * @param {number} endX - Ending X (row index).
 * @param {number} endY - Ending Y (column index).
 * @returns {Array} The solution path as an array of coordinates.
 */
export function solve(maze, startX = 0, startY = 0, endX = maze.length - 1, endY = maze[0].length - 1) {
  const visited = Array.from({ length: maze.length }, () => Array(maze[0].length).fill(false));
  const solution = [];
  let currentX = startX;
  let currentY = startY;

  while (currentX !== endX || currentY !== endY) {
    visited[currentX][currentY] = true;
    const options = getOptions(currentX, currentY, maze, visited);

    if (options.length === 0) {
      // Backtrack
      const [prevX, prevY] = solution.pop();
      currentX = prevX;
      currentY = prevY;
    } else {
      // Move to the next cell
      solution.push([currentX, currentY]);
      const [nextX, nextY] = options[0];
      currentX = nextX;
      currentY = nextY;
    }
  }

  solution.push([currentX, currentY]);
  return solution;
}

/**
 * Gets all valid moves from the current cell.
 */
function getOptions(x, y, maze, visited) {
  const options = [];
  const cell = maze[x][y];
  const rows = maze.length;
  const cols = maze[0].length;

  if (x + 1 < rows && !visited[x + 1][y] && cell[2] === 1) options.push([x + 1, y]); // South
  if (y + 1 < cols && !visited[x][y + 1] && cell[1] === 1) options.push([x, y + 1]); // East
  if (y - 1 >= 0 && !visited[x][y - 1] && cell[3] === 1) options.push([x, y - 1]); // West
  if (x - 1 >= 0 && !visited[x - 1][y] && cell[0] === 1) options.push([x - 1, y]); // North

  return options;
}
